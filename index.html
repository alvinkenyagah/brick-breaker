<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Three.js Brick Breaker</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            user-select: none; 
            touch-action: manipulation; 
            display: flex; 
            flex-direction: column; 
            height: 100vh; /* Ensures full viewport height for flex container */
        } 
        canvas { 
            display: block; 
            flex-grow: 1; /* Allows canvas container to take available space */
        }
        #scoreboard {
            position: absolute;
            top: 30px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 10;
        }


                #label {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 10;
        }



        #controls {
            width: 100%;
            display: flex; 
            justify-content: space-between; 
            padding: 10px; 
            background-color: #222; 
            box-sizing: border-box; 
            flex-shrink: 0; /* Prevents controls from shrinking */
        }
        #controls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            opacity: 0.8;
            flex-grow: 1; 
            margin: 0 5px; 
        }
        #controls button:first-child { margin-left: 0; }
        #controls button:last-child { margin-right: 0; }
        #controls button:active { opacity: 1.0; }

        /* Game Over Styles */
        #gameOverPopup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(53, 42, 42, 0.8); /* Darker overlay */
            color: white;
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .popup-content {
            background-color: #333;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 25px rgba(255, 68, 68, 0.226);
        }
        .popup-content h2 {
            color: #ff4444;
            font-size: 3em;
            margin-top: 0;
        }
        .popup-content p {
            font-size: 1.5em;
            margin-bottom: 30px;
        }
        .popup-content button {
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.5em;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        .popup-content button:hover {
            background-color: #cc3333;
        }
    </style>
</head>
<body>
    <div id="label">A.I.C Teen Digital Class</div>
    <div id="scoreboard">Score: 0</div>

    <div id="controls">
        <button id="left-button">&#9664; Left</button>
        <button id="right-button">Right &#9654;</button>
    </div>

    <div id="gameOverPopup">
        <div class="popup-content">
            <h2>GAME OVER!</h2>
            <p id="finalScoreText">Your final score: 0</p>
            <button id="playAgainButton">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 0. GAME CONSTANTS & INITIALIZATION ---

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        const FRUSTUM_SIZE = 15; 
        let ASPECT = window.innerWidth / window.innerHeight; 
        
        const camera = new THREE.OrthographicCamera(
            -FRUSTUM_SIZE * ASPECT / 2,  
            FRUSTUM_SIZE * ASPECT / 2,   
            FRUSTUM_SIZE / 2,            
            -FRUSTUM_SIZE / 2,           
            1,                           
            1000                         
        );
        camera.position.z = 10;
        
        // Dynamic Canvas Container Setup
        const gameViewDomElement = document.createElement('div');
        gameViewDomElement.style.flexGrow = '1';
        document.body.insertBefore(gameViewDomElement, document.getElementById('controls'));
        gameViewDomElement.appendChild(renderer.domElement);

        const GAME_AREA_HEIGHT = FRUSTUM_SIZE; 
        
        let PADDLE_WIDTH_DEFAULT = 3; 
        let PADDLE_WIDTH_MOBILE = 1.5; 
        let PADDLE_WIDTH = PADDLE_WIDTH_DEFAULT;
        const PADDLE_HEIGHT = 0.5; 
        const PADDLE_SPEED = 0.2;

        const BALL_RADIUS = 0.15;
        const BASE_BALL_SPEED = 0.08;
        
        const BRICK_WIDTH = 1.0; 
        const BRICK_HEIGHT = 0.4;
        const BRICK_ROWS = 7;    
        const BRICK_COLUMNS = 9; 
        const BRICK_PADDING = 0.1;
        
        let speedMultiplier = 1.0;
        let ballDirectionX = 1; 
        let ballDirectionY = 1; 
        let score = 0;
        const POINTS_PER_BRICK = 10;
        const POINTS_PER_HARD_BRICK = 25;
        let isPaused = false; 

        const scoreElement = document.getElementById('scoreboard');
        
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const controlButtons = document.getElementById('controls');

        const gameOverPopup = document.getElementById('gameOverPopup');
        const finalScoreText = document.getElementById('finalScoreText');
        const playAgainButton = document.getElementById('playAgainButton');
        
        const bricks = []; 
        const keys = { W: false, A: false, S: false, D: false, LEFT_BTN: false, RIGHT_BTN: false };
        
        let ballVelocity = { x: BASE_BALL_SPEED, y: BASE_BALL_SPEED };


        // --- 1. GAME OBJECT CREATION ---

        scene.background = new THREE.Color(0x330055);
        const backgroundGeometry = new THREE.PlaneGeometry(FRUSTUM_SIZE * 5, FRUSTUM_SIZE * 5); 
        const backgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x330055, side: THREE.DoubleSide }); 
        const backgroundMesh = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        backgroundMesh.position.set(0, 0, -1); 
        scene.add(backgroundMesh);

        let paddle; 
        const paddleMaterial = new THREE.MeshBasicMaterial({ color: 0x9999ff }); 

        function createOrUpdatePaddle() {
            const containerWidth = gameViewDomElement.clientWidth;
            const containerHeight = gameViewDomElement.clientHeight;
            const currentAspect = containerWidth / containerHeight;
            
            PADDLE_WIDTH = currentAspect < 1.0 ? PADDLE_WIDTH_MOBILE : PADDLE_WIDTH_DEFAULT;

            if (paddle) { 
                if (paddle.geometry.parameters.width !== PADDLE_WIDTH) { 
                    paddle.geometry.dispose(); 
                    paddle.geometry = new THREE.PlaneGeometry(PADDLE_WIDTH, PADDLE_HEIGHT);
                    
                    const currentAreaWidth = FRUSTUM_SIZE * currentAspect;
                    const halfWidthLimit = currentAreaWidth / 2 - PADDLE_WIDTH / 2;
                    paddle.position.x = Math.min(Math.max(paddle.position.x, -halfWidthLimit), halfWidthLimit);
                }
            } else { 
                const paddleGeometry = new THREE.PlaneGeometry(PADDLE_WIDTH, PADDLE_HEIGHT);
                paddle = new THREE.Mesh(paddleGeometry, paddleMaterial);
                scene.add(paddle);
            }
            paddle.position.set(0, -GAME_AREA_HEIGHT / 2 + PADDLE_HEIGHT, 0);
        }
        createOrUpdatePaddle(); 

        const ballGeometry = new THREE.CircleGeometry(BALL_RADIUS, 32);
        const ballMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 }); 
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        // Initial ball position set above paddle
        ball.position.set(0, -GAME_AREA_HEIGHT / 2 + PADDLE_HEIGHT + BALL_RADIUS * 2, 0); 
        scene.add(ball);

        function createBricks() {
            bricks.forEach(brick => scene.remove(brick));
            bricks.length = 0;

            const totalBrickWidth = BRICK_COLUMNS * BRICK_WIDTH + (BRICK_COLUMNS - 1) * BRICK_PADDING;
            const startX = -totalBrickWidth / 2 + BRICK_WIDTH / 2;
            const startY = GAME_AREA_HEIGHT / 2 - BRICK_PADDING - BRICK_HEIGHT / 2;

            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLUMNS; c++) {
                    
                    const isClosestRow = (r === BRICK_ROWS - 1);
                    const hits = isClosestRow ? 2 : 1;
                    
                    const brickGeometry = new THREE.PlaneGeometry(BRICK_WIDTH, BRICK_HEIGHT);
                    let baseColor = `hsl(${r * 40 + c * 5}, 80%, 60%)`;
                    
                    if (hits === 2) {
                        baseColor = '#AAAAAA'; 
                    }

                    const brickMaterial = new THREE.MeshBasicMaterial({ color: baseColor });
                    const brick = new THREE.Mesh(brickGeometry, brickMaterial);

                    brick.position.x = startX + c * (BRICK_WIDTH + BRICK_PADDING);
                    brick.position.y = startY - r * (BRICK_HEIGHT + BRICK_PADDING);

                    brick.userData.hitsRequired = hits;
                    brick.userData.originalColor = new THREE.Color(baseColor);
                    
                    scene.add(brick);
                    bricks.push(brick);
                }
            }
        }
        createBricks();


        // --- 2. INPUT HANDLERS ---

        window.addEventListener('keydown', (e) => {
            if (isPaused) return; 
            const key = e.key.toUpperCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (isPaused) return; 
            const key = e.key.toUpperCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });

        function setButtonState(buttonKey, state) {
            if (isPaused) return; 
            if (keys.hasOwnProperty(buttonKey)) {
                keys[buttonKey] = state;
            }
        }

        if (leftButton) {
            leftButton.addEventListener('mousedown', () => setButtonState('LEFT_BTN', true));
            leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); setButtonState('LEFT_BTN', true); });
            leftButton.addEventListener('mouseup', () => setButtonState('LEFT_BTN', false));
            leftButton.addEventListener('touchend', () => setButtonState('LEFT_BTN', false));
            leftButton.addEventListener('touchcancel', () => setButtonState('LEFT_BTN', false));
        }

        if (rightButton) {
            rightButton.addEventListener('mousedown', () => setButtonState('RIGHT_BTN', true));
            rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); setButtonState('RIGHT_BTN', true); });
            rightButton.addEventListener('mouseup', () => setButtonState('RIGHT_BTN', false));
            rightButton.addEventListener('touchend', () => setButtonState('RIGHT_BTN', false));
            rightButton.addEventListener('touchcancel', () => setButtonState('RIGHT_BTN', false));
        }
        
        if (playAgainButton) {
            playAgainButton.addEventListener('click', playAgain);
        }
        
        // --- Game Reset Function ---
        function playAgain() {
            gameOverPopup.style.display = 'none';
            
            score = 0;
            speedMultiplier = 1.0;
            isPaused = false;
            
            updateScoreDisplay();
            createBricks(); 
            
            // FIX: Position the ball just above the paddle and ensure UP direction
            ball.position.set(paddle.position.x, paddle.position.y + PADDLE_HEIGHT / 2 + BALL_RADIUS, 0); 
            ballDirectionY = 1; 
            
            recalculateVelocity();
        }


        // --- 3. MOVEMENT & GAME LOGIC FUNCTIONS ---

        function updateScoreDisplay() {
            scoreElement.innerText = `Score: ${score}`;
        }

        function recalculateVelocity() {
            ballVelocity.x = BASE_BALL_SPEED * ballDirectionX * speedMultiplier;
            ballVelocity.y = BASE_BALL_SPEED * ballDirectionY * speedMultiplier;
        }

        function updatePaddle() {
            if (isPaused) return; 

            const containerWidth = gameViewDomElement.clientWidth;
            const containerHeight = gameViewDomElement.clientHeight;
            const currentAspect = containerWidth / containerHeight;
            const currentAreaWidth = FRUSTUM_SIZE * currentAspect;

            let move = 0;

            if (keys.A || keys.LEFT_BTN) move -= PADDLE_SPEED;
            if (keys.D || keys.RIGHT_BTN) move += PADDLE_SPEED;
            
            paddle.position.x += move;

            const halfWidth = currentAreaWidth / 2 - PADDLE_WIDTH / 2;
            if (paddle.position.x > halfWidth) paddle.position.x = halfWidth;
            if (paddle.position.x < -halfWidth) paddle.position.x = -halfWidth;
        }

        function updateBall() {
            if (isPaused) return; 

            const containerWidth = gameViewDomElement.clientWidth;
            const containerHeight = gameViewDomElement.clientHeight;
            const currentAspect = containerWidth / containerHeight;
            const currentAreaWidth = FRUSTUM_SIZE * currentAspect;

            ball.position.x += ballVelocity.x;
            ball.position.y += ballVelocity.y;

            const rightBoundary = currentAreaWidth / 2 - BALL_RADIUS;
            if (ball.position.x > rightBoundary || ball.position.x < -rightBoundary) {
                ballDirectionX *= -1;
                recalculateVelocity();
            }

            const topBoundary = GAME_AREA_HEIGHT / 2 - BALL_RADIUS;
            if (ball.position.y > topBoundary) {
                ballDirectionY *= -1;
                recalculateVelocity();
            }

            // Game Over Check
            if (ball.position.y < -GAME_AREA_HEIGHT / 2) { 
                isPaused = true;
                finalScoreText.innerText = `Your final score: ${score}`;
                gameOverPopup.style.display = 'flex';
                
                // FIX: Immediately reset the ball's visual position when Game Over occurs
                ball.position.set(paddle.position.x, paddle.position.y + PADDLE_HEIGHT / 2 + BALL_RADIUS, 0);
                ballDirectionY = 1; 
                recalculateVelocity();
            }
        }

        function checkCollisions() {
            if (isPaused) return; 

            // PADDLE COLLISION
            if (ball.position.y - BALL_RADIUS < paddle.position.y + PADDLE_HEIGHT / 2 &&
                ball.position.y - BALL_RADIUS > paddle.position.y - PADDLE_HEIGHT / 2 &&
                ball.position.x + BALL_RADIUS > paddle.position.x - PADDLE_WIDTH / 2 &&
                ball.position.x - BALL_RADIUS < paddle.position.x + PADDLE_WIDTH / 2 &&
                ballVelocity.y < 0 
            ) {
                ballDirectionY *= -1; 
                const hitPoint = (ball.position.x - paddle.position.x) / (PADDLE_WIDTH / 2); 
                ballDirectionX = hitPoint * 1.5; 
                recalculateVelocity();
            }

            // BRICK COLLISION
            for (let i = bricks.length - 1; i >= 0; i--) {
                const brick = bricks[i];

                if (ball.position.x + BALL_RADIUS > brick.position.x - BRICK_WIDTH / 2 &&
                    ball.position.x - BALL_RADIUS < brick.position.x + BRICK_WIDTH / 2 &&
                    ball.position.y + BALL_RADIUS > brick.position.y - BRICK_HEIGHT / 2 &&
                    ball.position.y - BALL_RADIUS < brick.position.y + BRICK_HEIGHT / 2) {

                    const xDiff = Math.abs(ball.position.x - brick.position.x);
                    const yDiff = Math.abs(ball.position.y - brick.position.y);
                    
                    if (xDiff > yDiff) {
                        ballDirectionX *= -1; 
                    } else {
                        ballDirectionY *= -1; 
                    }
                    
                    brick.userData.hitsRequired -= 1;
                    
                    if (brick.userData.hitsRequired <= 0) {
                        scene.remove(brick);
                        bricks.splice(i, 1);
                        
                        const points = brick.userData.originalColor.getHex() === 0xAAAAAA ? POINTS_PER_HARD_BRICK : POINTS_PER_BRICK;
                        score += points;
                    } else {
                        const currentColor = brick.material.color.getHex();
                        brick.material.color.setHex(currentColor * 0.7); 
                        score += POINTS_PER_BRICK / 2;
                    }

                    updateScoreDisplay();
                    speedMultiplier += 0.015; 
                    recalculateVelocity();
                    
                    // Win Condition
                    if (bricks.length === 0) {
                        createBricks(); 
                        // FIX: Reset ball on win for clean new level start
                        ball.position.set(paddle.position.x, paddle.position.y + PADDLE_HEIGHT / 2 + BALL_RADIUS, 0); 
                        ballDirectionY = 1; 
                        speedMultiplier = 1.0; 
                        recalculateVelocity();
                    }
                    break; 
                }
            }
        }

        // --- 4. ANIMATION / GAME LOOP & RESPONSIVENESS ---

        function updateRendererSize() {
            // Get the current dimensions of the dynamic container
            const newWidth = gameViewDomElement.clientWidth;
            const newHeight = gameViewDomElement.clientHeight;

            // 1. Update Renderer's size
            renderer.setSize(newWidth, newHeight);

            // 2. Adjust camera boundaries
            const newAspect = newWidth / newHeight;
            camera.left = -FRUSTUM_SIZE * newAspect / 2;
            camera.right = FRUSTUM_SIZE * newAspect / 2;
            camera.top = FRUSTUM_SIZE / 2;
            camera.bottom = -FRUSTUM_SIZE / 2;
            camera.updateProjectionMatrix();
            
            // 3. Update Paddle size and position
            createOrUpdatePaddle(); 
        }

        updateRendererSize(); 

        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) { 
                updatePaddle(); 
                updateBall();
                checkCollisions();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', updateRendererSize);

        animate(); // Start the game loop

    </script>
</body>
</html>